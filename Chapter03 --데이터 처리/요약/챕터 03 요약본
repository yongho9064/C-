1.
표현할 수 있는 한계를 벗어나면 그 표현 범위의 반대편에서 부터 다시 시작한다.
예) short 최대값은 32767 에서 +1 해버리면 -32768로 넘어간다. (오버플로우)

2.
short형이 int형보다 크기가 작을 경우에는 short형을 사용하는것이 메모리를 절약할수있다
short형과 int형이 크기가 같을지라도 short형을 사용해야하는 이유가 16비트 int형을 사용하는
DOS시스템에서 32비트 int형을 사용하는 시스템으로 프로그램을 가져간다면 두 배의 메모리를 사용하기 때문 (오동작 이유도 있음)

3.
cout, cin 이 char형 변수를 처리하는과정은 cin은 키보드로 부터 입력된 M을 값 77로 변환한다. 출력할떄 cout은 값 77을
문자 M으로 변환한다. cin과 cout은 변수의 데이터형에 의해 안내를 받는다. 만약 동일한 값 77을 int 형 변수에 저장하면
cout은 77을 출력한다 (이 경우에 cout은 문자 7을 두 번 출력한다.)

4.
cout.put() 이 나타내는 의미는 클래스 객체인 cout을 통해 클래스 멤버 함수인 put()을 사용하겠다는 뜻이다.
(istream 클래스와 ostream 클래스) cout.put()이 왜 필요한가? 그 이유는 C++ Release 2.0 이전에 cout은
문자 변수들을 문자로 출력했지만, 'M' 이나 'N' 과 같은 문자 상수들은 수로 출력했다. 이 문제는 C와 C++의 초기버전들이
문자 상수를 int형으로 저장한 데에서 비롯되었다. C++ Release 2.0 이후에, 모든 C++들은 문자 상수를 int형이 아닌 char형으로 저장한다.

5.
if(65 == true) 이거보다 if('A' == true) 이러한 표기를 사용하는 것이 더좋다 왜냐하면 훨씬 명확하고 특정 코드 체계에 종속적이지
않기 때문이다 만약 ASCII 코드가 아닌 EBCDIC 코드 체계를 사용한다면 문자 A에 해당하는 수치 코드가 더 이상 65가 아니다. 그러나
'A' 라고 표기하는 것은 여전히 문자 A를 나타낸다.

6.
- 유니버셜 네임코드
시스템이 확장, 새로운 다른 나라 언어 등을 위해 만든 세트가 존재
\u,U 뒤에 16진수가 오는데 뒤에 숫자는 그 문자에 해당하는ISO 10646 코드를 나타낸다. Ex)K\u00F6rper; --> 프랑스어
 
- char은 unsigned나 signed로 미리 설정 X => 원하는 경우에 직접 명백하게 제한해주어야 한다.
- 확장 char : wchar_t -> 2byte로 설정 / 기초 데이터형 이라고 불린다.
  cout,cin은 처리x => wcin or wcout을 사용해야하고 문자열 앞에 l or L을 붙여주어야 한다. Ex)wcout<<L"tall"<<endl;
+ char16_t ,chat32_t 형이 추가로 개발 ( 16 : u , 32, U )

7.
부동소수점수를 나타내는 방법은 3.45E6과 같이 지수표기를 사용하는 것이다.
여기서 6은 지수 3.45는 가수 라한다. 부동 소수점수의 장점은 스케일을 사용하여 매우 큰 범위의 값을 나타낼 수 있다.
단점은 정밀도를 잃을 수 있다.

8.
int dues = 20 * 5 + 24 * 6 결합 방향 규칙에 의해 왼쪽에 있는 곱셈이 먼저 수행될것이라고 지레짐작할 수도 있다.
그러나 이 경우는 두 개의 * 연산자가 하나의 피연산자에 걸려 있는 상황이 아니므로 결합 방향 규칙을 적용할수 없다.
실제로 이것은 가장 효율적인 순서가 되도록 C++ 시스템에 맡겨진다.


