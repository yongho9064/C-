1.
헤더파일 에는 다음과 같은 것들을 넣는다.
(함수원형, #define이나 const를 사용하여 정의하는 기호상수, 구조체 선언, 클래스 선언, 템플릿 선언, 인라인 함수)
함수 정의나 변수 선언은 헤더파일에 넣으면 안된다. 하나의 프로그램을 구성하는 두 파일에 그 헤더 파일을 가각 포함시키면
한 프로그램에 같은 함수 정의가 두번 있게 되어 에러가 발생한다.

2.
헤더 파일을 어떤 파일에 포함시킬 때에는 단 한번만 포함 시켜야한다. 헤더 파일을 여러번 포함시키는 실수를 저지르기 쉽다
C와 C++에서 헤더파일을 여러번 포함시키는 실수를 피하기 위해 사용하는 표준 기법이 있다. 전처리기 지시자 #ifndef를 사용하는 것이다.
#ifnded COORDIN_H_ ~~~  #endif // COORDIN_H_라는 이름이 전처리기 지시자 #define에 의해 정의 되어 있지 않은 경우에만
#ifnded와 #endif 사이에 있는 구문들을 처리하라는 뜻이다.

3.
자동변수(지역변수): 함수 매개변수와, 함수 안에서 선언된 변수는 기본적으로 자동 기억 존속 시간을 가진다. 이들은 또한 지역 사용 범위를 가지며
링크는 없다. 예를 들어 main()안에 서 texas라는 변수를 선언하고 oil()이라는 함수 안에서 같은 이름으로 또 하나의 변수를 선언하면
서로 독립적이면서 자신이 정의된 함수 안에만 알려지는 두개의 texas 변수를 생성하는 것이된다.

4.
정적변수: C와 마찬가지로 C++는, 세 가지 유형의 링크(외부 링크, 내부 링크, 링크 없음)를 가지는, 정적 변수를 제공한다. 세 가지 유형 모두 프로그램이
실행되는 시간동안 존속한다. 그들은 자동변수(지역변수)보다 수명이 길다. 정적변수는 실행되는 동안에 변하지 않기 떄문에 스택과 같은 특별한 장치는 필요없다
그대신 컴파일러는, 모든 정적변수를 수용할 수 있을 만큼 넉넉하게 크기가 정해진 메모리 블록을 대입한다. 이 블록에 저장되는 정적변수는 프로그램이 실행
되는 동안에 계속 존재한다. 정적변수를 명시적으로 초기화 하지않으면 컴파일러는 그것들을 모두 0으로 초기화한다. 정적 배열과 구조체도 0으로 초기화한다.

5.
외부변수를 사용할려면 extern키워드를 사용한다 초기화는 제공하지않는다. 그렇지 않을 경우, 선언은 정의이다.(extern char gr = 'z') // 초기화되므로 정의이다
만약 여러 파일에서 외부 변수가 사용될 경우 오직 1개의 파일이 그 변수에 대한 정의를 지닐 수 있다! (유일 정의 원칙) 예) file1.cpp 에다가 int i를 선언하고
file2.cpp 에다가 int i를 사용하면 실패한다. 왜냐하면 단일 변수를 정의해야하는 규칙에 위배되기 때문이다. 프로그램은 int i를 2개를 정의한 것으로 간주하면서
에러가 발생한다. 만약 다른파일에 같은 이름으로 사용하고 싶다면 static을 사용하면된다(static int i) static으로 선언된 변수는 그 파일에서만 사용 가능하다.

6.
전역변수는 외부 링크를 갖도록 디폴트로 내정되어 있지만 const 전역변수는 내부 링크를 갖도록 디폴트로 내정되어있다. const 정의를 마치 static 제한자가
사용된것 처럼 취급한다. (const int fingers = 10 <-- static const int fingers와 같다) 

7.
함수 역시 링크 속성을 가진다 C와 마찬가지로 C++는 하나의 함수 안에서 다른 함수를 정의할 수 없다. 따라서 모든 함수는 자동적으로 정적 기억 존속 시간을
가진다. 이것은 프로그램이 실행되는 동안 모든 함수가 계속 존재한다는 것을 의미한다. 또한 static 키워드를 사용하여 함수의 사용범위를 하나의 파일로 제한
할수 있다. 따라서 같은 이름의 함수를 다른 파일에서도 사용할 수 있다는 것을 의미한다.

8.
이름공간은 전역 위치에 또는 다른 이름 공간안에도 놓일수 있다. 그러나 블록안에는 놓일 수 없다. 이름공간은 기본적으로 외부 링크를 가진다.

9.
이름을 간편하게 사용할수 있는 using 선언과 using 지시자라는 두가지 방법을 제공한다 using 선언은 하나의 특별한 식별자를 사용할 수 있게 만들고 using 지시자는
그 이름 공간 전체에 접근할수 있게 만든다. using 선언은 제한된 이름 앞에 키워드 using을 붙이는 것이다. (using Jill::fetch) // using 선언 이렇게 선언하면
Jill::fetch 대신에 fetch라는 이름을 사용할수 있다.

10.
using선언은 하나의 이름만 사용할 수 있게 만든다. 이와는 대조적으로 using 지시자는 모든 이름을 사용할 수 있게 만든다. using지시자는 하나의 이름 공간 앞에
using namespace라는 키워드를 붙이는 것이다. 이렇게 하면 사용 범위 결정 연산자(name::value)를 사용하지 않고도 그 이름 공간에 속한 모든 이름을 사용할수 있다.
using namespace Jill // Jill에 속한 모든 이름을 사용할 수 있게 만든다.

11.
namespace{} 이런식으로 이름을 생략하면 using 지시자나 using 선언을 명시적으로 사용한다. 그 이름 공간에 들어 있는 이름들은 다른곳(링크)에서 사용할수가 없다.

12.
이름 공간의 가이드라인
1. 외부 전역 변수를 사용하지 말고, 이름이 명명된 이름 공간에 있는 변수를 사용하라
2. 정적 전역변수를(static)사용하지 말고, 이름이 명명되지 않은 이름 공간에 있는 변수를 사용하라
3. 함수 또는 클래스 라이브러리를 개발하고 있다면 그들을 하나의 이름 공간에 넣어라
4. using지시자는 옛날 코드를 이름 공간 용도로 변환하는 임시 수단으로만 사용하라
5. using지시자를 헤더 파일에 사용하지 마라, 그이류는 그렇게 하면 어떤 이름들을 사용할 수 있게 하는지 알수없다. using지시자를 사용한다면 
그것을 #include 전처리 지시자 뒤에 놓아라
6. using 선언에 대해 전역 범위 대신 선태적으로 지역 범위를 사용하라
7. 사용 범위 결정 연산자 (name::value) 또는 using 선언을 사용하여 이름을 선택적으로 들여오라
