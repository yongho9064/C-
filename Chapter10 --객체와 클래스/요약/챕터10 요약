1.
클래스는 일반적으로 데이터 항목들은 private부분에 선언된다. 클래스 인터페이스를 구성하는 멤버 함수들은(메소드) public 부분에 선언된다.

2.
멤버 함수(메소드)의 함수 머리는 그 함수가 어느 클래스에 속하는지 나타내기 위해서 사용 범위 결정 연산자(::)를 사용해야 한다.
(void Stock::update(double price)) 이것은 Stock클래스의 멤버 함수(메소드)인 update()함수를 정의한다는 의미이다.
Stock클래스에 속해 있는 다른 멤버 함수들은 사용 범위 결정 연산자를 사용하지않고도 update()메소드를 마음대로 사용할수 있다.
그 이유는 그들이 같은 클래스에 속해 있어, update()를 사용 범위 안에 넣기 때문이다.

3.
클래스 선언 안에 정의를 가지고 있는 모든 함수는 자동으로 인라인 함수가 된다. 클래스 선언은 짧은 멤버 함수(메소드)들에 대해서 인라인 함수를
사용하는 경우가 많다.

4.
데이터를 pulbic으로 만드는것은 데이터 은닉이라는 클래스 사용의 기본 원칙을 위반하는 것이다.

5.
생성자는 리턴값이 없다 생성자는 객체를 선언할 떄 프로그램이 자동으로 생성자를 호출한다. 사용자가 생성자를 제공하지 않아도
C++가 자동으로 디폴트 생성자를 제공한다 그것은 디폴트 생성자의 암시적 버전인데 아무런 일도 하지않는다.
사용자 정의 생성자를 작성하면 자동으로 생성되지 않는다. 이유는 초기화되지 않은 객체의 생성을 사용자가 원하지 않을 수도 있기 때문

6.
클래스 객체의 수명이 다했을 때 파괴자는 자동으로 호출되는 것이기 때문에 반드시 파괴자가 있어야 한다. 사용자가 파괴자를 제공하지 않으면, 컴파일러
가 디폴트 파괴자를 선언한다. 객체를 파괴하는 코드를 발견하면 컴파일러는 그 파괴자를 위한 정의를 제공한다. 일반적으로 사용자가 코드에 명시적으로
파괴자를 호출하면 안된다. 또한 파괴자는 매개변수를 가지지못한다.

7.
const객체를(const Car test) 선언하고 멤버함수(메소드) 괄호뒤에 const키워드를 넣는것이다. 
예) void show() const // 호출 객체를 변경하지 않는다고 약속한다. 구문상의 문제 때문에 이와 같은 방식으로 해결해야한다.

8.
생성자는 클래스와 같은 이름을 가진다. 그러나 함수 오버로딩 이라는 멋진 기법을 통해서 같은 이름을 사용하는 생성자를 하나 이상으로 가질수 있다.
이 경우에 각각의 생성자는 자신만의 유일한 시그내처 또는 매개변수 리스트를 가져야 한다.

9.
파괴자는 클래스당 하나만 가질 수 있다. 파괴자는 리턴값을 갖지 않으며(void형도 안된다)매개변수도 갖지않는다. 파괴자의 이름은 클래스 이름 앞에
틸데(~)가 붙은 것이다. 예를 들어 Bozo 클래스의 파괴자는 다음과 같은 원형을 가진다. (~Bozo()) // 클래스 파괴자
클래스 파괴자는 클래스 생성자가 new를 사용할 떄 필요하게 된다.

10.
객체의 멤버함수(메소드)들은 각각 this 포인터를 가진다. this포인터의 특별한 특징은 호출한 객체를 지시하는 것이다. 호출한 객체를 메서드가
전체적으로 참조할 필요가 있을 경우에는 *this를 사용할수 있다. (멤버함수(메소드) 매개변수에 this가 숨어져있다.)

11.
객체들이 배열을 초기화하는 방식은 처음에 디폴트 생성자를 사용하여 배열의 원소들을 생성한다. 그런 다음 중괄호 안에있는 생성자들이 임시객체를 생성하고
그내용을 배열 원소에 복사한다. 그러므로 클래스 객체들의 배열을 생성하려면 클래스가 하나의 디폴트 생성자를 가져야 한다.

12.
클래스안에 상수멤버(상수변수)를 사용해서 배열의크기를 알려주면 오류가 뜬다. 그 이유는 상수멤버(상수변수)의 값을 알지 못하기 때문이다. 
클래스를 선선하는 것은 객체가 어떻게 생겼는지 서술하는 것이지 그 객체를 생성하는 것은 아니기 떄문이다. 따라서 값을 저장할 기억공간은
객체가 생성될 떄까지 마련되지않는다. 그렇기에 클래스 선언부 내부에 상수를 사용하려면 두가지 방법이 있다.

1.enum을 사용한다: enum은 정의만으로 메모리할당이 되지 않으며 그래서 객체에 데이터 멤버를 생성하지 않는다 define처럼 치환되는 방식이므로
객체가 생성되지 않아도 사용이 가능하다.
2.static을 사용한다: 클래스 선언부 내부에 static을 사용하면 전역메모리에 올라가며 같은 클래스의 객체가 공유하고 사용 가능한 정적 멤버 변수가 된다.

13.
전통적인 열거는 몇 가지 문제점을 안고 있다. 그중하나는 만약 enum a{i,j} enum b{i,j}를 정의했다면 이 구문은 제대로 작동하지않는다. 왜냐하면
a, b의 식별자와 이름이 충돌되기 떄문이다.(i,j) C++11은 새로운 열거자 형식을 제공하여 열거자에게 클래스 범위를 갖게 함으로써 이문제를 해결한다.
enum class a{i,j} enum class b{i,j} 열거자가 클래스 범위를 가지고 있기 때문에 저렇게 다른 enum정의의 식별자와 이름이 충돌할 가능성을 없앴다.
또다른 방법으로는 클래스 대신에 struct키워드를 사용할수있다. enum struct a{i,j} 기존에 그냥 사용했던것과 다르게 구별할 문법이 필요한데 
enumName::을 사용하면 된다. (a::i) (b::j) <-- 이런식으로 (마지막으로 범위가 있는 열거는 int형으로의 암시적 전환이 이루어지지 않는다.)


