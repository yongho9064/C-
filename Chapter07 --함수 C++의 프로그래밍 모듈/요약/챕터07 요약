1.
일반적으로 함수를 정의할때에는 main()을 가장 앞에 두는 것이 관례이다.

2.
void function() C++에서 괄호 안을 비워 놓아도 그 안에 void라는 키워드가 들어 있다고 간주한다. 이것은 그 함수가 어떠한 매개변수도
요구하지 않는다는것을 의미한다. 그러나 C에서 괄호안을 비워 놓는 것은 매개변수가 무엇인지 밝히는 것을 거부한다는 뜻이다.
이말은 매개변수 리스트가 무엇인지 확인하지 않겠다는 것이다. C++에서 이것을 나타내는 방법은 "생략 부호"를 사용하는 것이다.
void function(...) // C++에서 매개변수 리스트 확인 포기 

3.
매개변수의 데이터형이 불일치하는 경우에는 C에서는 이러한 경우에 이상한 에러를 발생한다. 예를 들어 매개변수로 int형값을 기대하는 함수에
double형 값을 전달하면 그, 함수는 double형의 (double)64비트 중에서 앞부분 (int)32비트만 참조하여 그것을 int형값으로 처리한다 그러나
C++에서 함수 원형에 정의되어 있는 데이터형으로 자동 변환시켜준다. (매개변수로 (int)2를 전달하면 double형으로 2.0 변환된다.)

4.
배열의 값을 변경하고 싶지 않을 경우 const를 사용하면된다 하지만 그 배열의 원소들은 기본형이어야 한다. 그 배열의 원소들이 포인터이거나
포인터를 지시하는 포인터인 경우에는 const를 사용할수 없다.

5.
int arr[3] 배열의 arr 이름은 배열의 첫 번째 원소의 주소이다 그러나 &arr는 전체 배열의 주소이다.
한 가지 큰 차이는 arr+1은 배열 내 다음 원소의 주소이고 &arr + 1은 배열 뒤로 12바이트 다음 블록의 주소라는 것이다. 

6.
auto는 자동 형 변환은 단일 값을 초기화할 떄 사용되면, 리스트를 초기화할 때는 사용할수 없다.
예) auto i = {1,2,3} // int형 배열로 저장되기를 원했지만 불가능!

7.
"포인터 배열"은 포인터가 여러개 모여서 배열로 있는것이고   // int * (ptr[3]) = {&n1,&n2,&n3}
"배열 포인터"는 배열 타입을 가리키는 하나의 포인터 라는 것 입니다.  // int (*ptr)[3] = &n1

8.
typedef 키워드를 이용해서 데이터 형에 가명을 붙일 수 있다. typedef const double *(*p_fun)(const double *, int)
이기법은 식별자를 가명으로(p_fun)설정한다. 그래서 이와같이 만들수있다. (p_fun p1 = f1) 
typedef는 단지 입력한 가명을 저장할 뿐만 아니라 코드를 작성하면서 오류를 주면서 프로그램을 더 쉽게 이해할 수 있게 도와준다.
