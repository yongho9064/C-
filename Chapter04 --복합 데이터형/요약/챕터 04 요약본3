1.
C++에서 포인터를 생성하면 컴퓨터는 주소를 저장하기 위한 메모리를 대입한다. 
이것은 그 포인터가 지시하는 데이터를 저장하기 위한 메모리를 대입하는 것이 아니다. 
데이터를 저장하기 위한 메모리를 대입하는 것은 다른 단계이다. 
int *p  // 이렇게 생성만하고
*p = 10 // 어딘지 알수 없는 곳에 값을 저장한다.
왜냐하면 p에 주소를 대입하는 단계를 빠뜨렸기 때문이다. 그러면 어딘지 모르는 주소의 데이터값을 10으로 바꾸어 버린다.
이는 매우 위험한 상황이며 이런 에러가 가장 찾기 힘든 버그를 야기한다.
즉 포인터를 사용할 때에는 *를 사용하기 전에 포인터를 적절한 주소로 초기화 시켜줘야한다.
(포인터를 사용할 떄에는 간접 참조 연산자(*)를 사용하기 전에 반드시 포인터를 적절한 주소로 초기화시켜 주어야 한다.)

2.
포인터는 정수형이 아니다. 포인터는 위치를 나타내는 것이다. 따라서 포인터에 정수를 직접 대입할 수 없다.
다시 말해서 int *pt = 0xFFFFFF 좌변이 포인터이고 우변이 정수이기 때문에 에러가 발생한다.
하지만 pt = (int*)0xB2000000 을 하면 데이터형이 일치하여 컴파일이 된다.
즉! 내가 임의의 주소를 대입할 수 있다는 이야기이다.

3.
포인터를 변수의 주소로 초기화 하였을때 포인터는 이름에 의해 직접 접근할 수 있는 메모리를 위한 대용 이름을 단순히 제공한다.
이것 뿐만 아니라 프로그램을 실행하는 동안에 이름이 없는 메모리를 대입하는 것이 포인터의 진정한 가치이다.
new를 사용한 이러한 메모리 대입은 프로그램이 실행되는 동안에 일어난다.

4.
컴퓨터에 메모리가 부족하면 new의 메모리 대입 요청을 허용할 수 없는 상황이 발생할 수도 있다. 이러한 경우에 new는 0값을 리턴한다.
C++에서는 값이 0인 포인터를 Null포인터 라고 부른다. 널 포인터는 어떠한 데이터도 지시하지 않는다.

5.
new로 할당한 메모리를 다시 메모리 풀로 회수하는 것이 delete연산자이다.
delete는 new와 항상 함께 사용한다. 
int *p = new int
delete p <-- 이렇게 사용한다. delete를 해주지 않으면 메모리 누수가 일어나 프로그램이 먹통이 될 수도 있다.
delete를 널 포인터에 사용하는 것은 안전하다.

6.
- new를 사용한 동적 배열
복합 데이터형 즉 배열, 문자열, 구조체와 같은 커다란 데이터를 다룰 때에는 new를 사용하는 것이 훨씬 더 편하고 효율적이다.
큰 데이터를 다룰 때에는 프로그램이 컴파일될 때 데이터를 위한 메모리가 대입된다. 프로그램이 실행될 때 이 데이터는 사용이
되든 안되든 메모리를 차지한다. 이 방식을 정적 바인딩(static binding)이라 한다. 
이것은 데이터가 컴파일 시간에 생성된다는 것을 의미한다.
그러나 new를 사용하면 배열을 실행 시간에 생성할 수 있고, 필요 없으면 생성하지 않을 수 있다. 
또는 프로그램을 실행하는 동안에 배열의 크기를 결정할 수 있다. 이러한 방식을 동적 바인딩(dynamic binding)라 한다. 
이것은 배열이 실행시간에 생성된다는 것을 뜻한다 이러한 배열을 동적배열(dynamic array)이라 한다.

7.
new와 delete를 사용할 때 다음과 같은 규칙을 지켜야 한다.

- new로 대입하지 않은 메모리는 delete로 해제하지 않는다.
- 같은 메모리 블록을 연달아 두번 delete로 해제하지 않는다.
- new [] 로 메모리를 대입한 경우에는 delete []로 해제한다.
- new를 대괄호 없이 사용했으면 delete도 대괄호 없이 사용한다.
- 널 포인터에 delete를 사용하는 것은 안전하다(아무 일도 일어나지 않는다.)

8.
int *pt = new int;
short *ps = new short[100];
delete [] pt; 
delete ps               // 에러가 나야 하는것으로 알고있는데 컴파일러에서 에러가 나지 않는다.
// 첫번째 주소만 해제되고 나머지는 그대로 남아 메모리 누수가 발생한다. 이는 매우 위험하다. 따라서 반드시 위 처럼 실수 하지 말자.

9.
-- 배열의 주소 --
short tell[10]              // tell은 20바이트 배열이다
cout << tell << endl        // &tell[0]을 출력한다
cout << &tell << endl       // 전체 배열의 주소를 출력한다
그래서 tell + 1은 주소값에 2를 더하게 되고 &tell + 1은 주소값에 20을 더하게된다
short (*pas)[20] = &tell    //  pas는 20바이트 배열을 가리킨다.
명심하자 배열의 이름이 배열의 주소 아닌가? 절대로 아니다 배열의 이름은 배열의 첫 번째 원소의 주소이다.
반면 주소?연산자를?적용하면?전체?배열의?주소가?산출된다.

10.
char flower[10] = "rose"
cout << flower << "s are red\n"
배열 이름은 첫번째 원소의 주소이다 여기서 cout 구문에 있는 flower는 문자 r가 들어 있는 char형 원소의 주소이다.
cout 객체는 그 주소를 문자열의 주소라고 간주하여 그 주소에 있는 문자를 출력한 후, 널 문자(\0)를 만날 떄까지 계속해서
문자들을 출력한다. 다시 말해서 cout에 문자의 주소를 넘겨주면 그 문자부터 시작해서 널 문자를 만날때까지 출력한다.
"s are red\n" 또한 문자열의 첫번쨰 문자의 주소를 나타낸다.

11.
문자열 상수를 상수로 취급하라는 것이 C++의 권고 사항이다.
어떤 컴파일러는 동일한 문자열 상수가 프로그램에 여러 번 나타날떄 그것들을 하나의 문자열 상수를 사용하여 나타낸다

12.
구조체 식별자가 구조체의 이름이면 도트 멤버 연산자를 사용하고
구조체를 지시하는 포인터이면 화살표 멤버 연산자를 사용하면 된다.

