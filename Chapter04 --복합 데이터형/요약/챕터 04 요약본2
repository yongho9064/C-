1.
cin.getline()을 사용하는 것이 아닌 
getline(cin, str) 이렇게 사용한다. 이것은 도트가 없으므로 클래스 메서드가 아니라는 것을 알 수 있다.
문자열 크기를 string은 알아서 잡아주기 때문에 따로 설정을 할 필요가 없다.

2.
getline()는 istream 클래스 메서드인 것이 있고 아닌 것이 있다. 그 이유는
istream 클래스는 string 클래스가 추가되기 오래 전부터 C++의 일부였다. 그래서 istream 설계는 기본 데이터형만 인식하여 string형은
인식하지 못한다. 그러므로 double, int 등 기본 데이터형을 처리하는 클래스 메서드들은 있지만
string 객체를 처리하는 istream클래스 메서드는 없다. 
cin.getline(), getline() 차이점은 cin.getline()은 배열을 저장하고 getline()은 string객체에 저장한다

3.
raw문자열이라는 것도 있다.
raw문자열에선 문자들이 독립적으로 존재한다. 예를 들어 \n이 newline으로 인식되지 않는다. 쓰여진 그대로 \n이 입력된다.
cout << R"(돌아서면 "하이"라고 할까 무서워\n \b \a 핳핳)" 을 실행하면
그대가 돌아서면 "하이"라고 할까 무서워\n \b \a 핳핳 이 출력된다. 이 문자열 사이에 엔터키가 있으면 그대로 진짜 입력한 그대로 출력된다. 

cout << R"(돌아서면 "하이"라고 할까 
무서워\n \b \a 핳핳)" 을 실행하면

돌아서면 "하이"라고 할까 
무서워\n \b \a 핳핳 

이렇게 출력된다.

괄호를 만약 쓰고 싶다면 양식이 조금 달라진다. raw 문자열은 처음 "와 ( 사이의 문자가 마지막 부분의 )과 " 사이에 똑같이 있으면 된다..
이게 raw 문자열의 시작과 끝을 알려준다고 생각하면 된다. 다음과 같은 식이다.
cout << R"*+(그대가 돌아서면 ("하이")라고 할까 무서워\n \b \a 핳핳 \\)*+"       // *+가 포인트이다. 구분자라고도 한다.
이 구분자는 공백, 괄호, 백슬래시, 탭 빼고 다 사용할 수 있다.
접두어 R은 wchar_t 등의 raw 문자열을 생성하기 위해 사용되는 다른 문자열 접두어와 혼용이 가능하다.

5.
C 언어에서는 구조체 변수를 선언할떄 키워드 struct를 요구한다. 그러나 C++에서는 키워드 struct를 생략할 수 있다.
struct inflatable goose      // C는 키워드 struct를 요구한다.
inflatable vincent           // C++는 키워드 struct를 요구하지 않는다.

6.
일반적으로 프로그래머들은 모든 함수들이 구조체를 사용할 수 있도록 구조체를 외부적으로 선언하고 있다.
또한 변수도 내부적으로 또는 외부적으로 선언할 수 있다. 외부 변수는 여러 함수들이 공유할 수 있다.
C++의 일반적인 관행은 외부 변수의 사용은 가급적 금지한다. (메모리 관리 때문이다) 

7.
리스트 초기화 기능을 사용할수 있다. inflatable mayor {} <-- 모두 0으로 초기화
narrowing(오버플로우)은 허용되지 않는다.

8.
- 구조체 안의 비트 필드
구조체는 멤버들이 각각 일정 비트 수를 차지하도록 지정할 수 있다.
이것은 어떤 하드웨어 장치에 들어 있는 레지스터에 대응하는 데이터 구조를 만들 때 매우 편리하다.
사용할 비트 수는 콜론을 찍고 그 뒤에 적는다. 이름이 없는 필드를 사용하여 간격을 줄 수도 있다. 
이러한 각 멤버를 비트 필드라 한다.
struct memory
{
unsigned int AA : 4;
unsigned int : 4;
bool On : 1;
bool torgle : 1;
};
비트 필드는 저수준 프로그래밍에서 주로 사용된다.

9.
공용체(union)는 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식이다.
즉 구조체는 int, long, double 등등 한꺼번에 보관할 수 있지만, 공용체는 어느 하나만 보관할 수 있다.
구문은 구조체와 같지만 의미가 다르다.
여러 가지 데이터형을 사용할 수는 있지만, 이들을 동시에 사용할 수 없을 때, 공용체를 사용하면 메모리를 절약할 수 있다.
예로 일부는 정수 일부는 문자열로 인식하는 코드를 짜는 경우를 들 수 있다.

10.
열거체는 대입 연산자만 사용하도록 정의되어 있다. 특히,산술 연산이 허용되지 않는다.
그러나 일부 C++는 이 제한을 지키지 않는다 즉, 데이터형 제한을 위반할 수 있다.
다시 강조하지만, 이식성을 최대한 높이기 위해 이 제한을 지키는 것이 좋다.

11.
대입 연산자를 사용하여 열거자의 값을 명시적으로 지정할 수 있다.
enum bits {one = 1, two = 2, four = 4, eight = 8}
이때 대입되는 값들은 정수여야 한다. 또한 일부 열거자에만 명시적으로 값을 대입 할수 있다.
enum bigstep {first,second = 100, third}
이런한 경우에first는 기본적으로 0이고 뒤에 오는 초기화하지 않은 열거자들은 바로 앞의 열거자보다 1만큼 크다
그래서 third는 101이 된다.
마지막으로, 하나 이상의 열거자들이 같은 값을 가질 수 있다.
enum {zero, null = 0, one, numero_uno = 1}
여기서 zero와 null이 0이고 one과 numero_uno가 1이다.

12.
C++ 초기 버전에서는 열거자에 int형 값(또는 int형으로 승급될 수 있는 값)만을 대입할 수 있었다.
그러나 지금은 그러한 제한이 없어졌기 때문에 long형 값을 열거자에 대입 할 수 있다.

13.
enum num{one = 1, two = 2, four = 4, eight = 8} // 만약 이러한 열거체가 선언된 후 
num n = num(6) 을 하면 어떻게 될까?
열거체 값의 범위는 상한을 찾기 위해 열거자 값 중에서 최대값을 취한다. 그리고나서 이 최대값보다 큰 2의 최소 거듭제곱을
구하고, 거기에서 1을 뺀 것이 상한 값이다. 여기선 최대값이 8 이고 이 수보다 큰 2의 최소 거듭제곱은 16이고 1을 빼면 15가 나온다.
따라서 15가 상한이다. 하한은 열거자 값 중에서 최소값을 취한다. 그리고 0이거나 0보다 크면 하한은 0이다. 
최소값이 만약 음수이면 상한 처럼 구한후 -를 붙여준다. 따라서 위의 num의 범위는 0~15이다.
이 범위를 정의하는 것은 열거체를 보관하기 위해 얼마만큼의 공간을 할당하느냐에 관계가 있다.