1.
컴파일러는 사용자가 적법한 인데스를 사용하는지를 검사하지않는다 
예를 들면char arr[8] 배열 범위를 초과하는 arr[20] 에다가 값을 대입해도 컴파일러는 유효성 검사를 하지않는다. 
이유는 메모리 주소를 표현하는 하나의 형식이기 떄문이다. 그러나 그러한 무모한 대입은 프로그램이 실행될떄 문제를 일으켜 데이터나
코드를 망가뜨리고 프로그램이 먹통이 되게한다. 그러므로 반드시 적법한 인덱스를 사용해야 한다.

2.
컴파일러가 배열 원소의 개수를 결정하도록 위임하는 것은 좋지 않다. 예)things[]
이유는 프로그래머가 생각한 개수와 컴파일러가 결정한 개수가 다를 수 있기 떄문이다. 
그러나 char형의 배열을 문자열로 초기화 할떄에는 오히려 이와 같은 접근이 더 안전한 방법일 수있다.

3.
리스트 초기화는 3가지 장점이 있다.
초기화시 = 을 생략할 수 있다.
중괄호를 공백으로 모든 배열을 0으로 초기화 할 수 있다.
리스트 초기화시 narrowing(오버플로우)을 방지 할 수 있다.  // 현재는 경고가 뜬다. 옛날에는 오류로 발생하여 컴파일이 되지 않았다.

5.
문자열은 키보드 입력으로 받을 때 문제점이 두 개가 있다.
첫 째는 cin으로 문자열을 받을시 빈칸이 있으면 이상한 문제가 발생한다. 예를 들어
 const int SIZE = 20;
 char name[SIZE];
 char name2[SIZE];
 cin >> name; // qwe asd 입력
 cin >> name2; // 실행이 안되고 넘어감
 cout << name << endl; // qwe 출력
 cout << name2; // asd 출력
이 이유는 cin이 문자열의 끝을 인식하는 방법 때문이 발생한다. 키보드로 끝내기 널 문자를 입력할 수 없기 때문에, 
cin에게 문자열의 끝을 알려주는 다른 수단이 필요하다. 
그래서 cin은 빈칸, tab, 캐리지 리턴과 같은 화이트스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주한다.
즉, 화이트스페이스를 만나면 그것을 널 문자로 대체하고 문자열의 끝으로 받아드린다.
qwe asd를 입력했을때 qwe asd는 입력 큐(inout Queue)에 들어간다. (큐는 자료구조때 배워라)
어쨋든 큐에 들어가면 출력할때 cin은 qwe빈칸을 만나고 빈칸을 \0로 대체한다. 그러면 입력 큐에는 asd캐리지리턴이 남아있는다.
거기서 cin >> name2를 했을 시 입력 큐에 데이터가 들어있어서 키보드 입력을 대기하지 않는다. 그래서 name2에 asd캐리지리턴이
들어가고 캐리지리턴을 \0으로 변환 후 asd가 name2에 입력된다.
둘 째는 cin을 사용할 때 문자열의 크기 이상으로 입력을 넣을 수 있다. 그럴 경우 다른 메모리의 값들을 변경시켜버리기 때문에 위험하다.
실행시 뻑이나서 프로그램이 종료될 것이다. 뻑이난다는 건 프로그램이 멈추고 응답없음 같이 종료되는 것이다.

6.
getline() 함수는 엔터 키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다.
그러나 개행 문자는 저장하지 않는다. 문자열 배열에 저장 시 개행 문자는 널 문자로 대체된다.
getline()은 개행 문자를 읽어서 폐기하는 반면에, get()은 입력 큐에 개행 문자를 남겨 둔다.

7.
cin.get(name,ArSize).get() 이와 같이 사용하면 cin.get(name,ArSize) 가 cin 객체를 리턴한다.
리턴된 cin 객체는 뒤에 결합된 get() 함수를 호출하는 객체로 사용된다.

8.
C++에서는 매개변수 리스트를 다르게 하면 같은 이름을 가진 함수의 여러 변종을 사용할 수 있다는 것이다.
예를 들어 cin.get(name,ArSize) 를 사용하면 컴파일러는 문자열을 읽어 배열에 저장하라는 뜻으로 알아듣고
구애 알맞은 멤버 함수를 호출한다. 그렇지 않고 매개변수 리스트가 없는 cin.get()을 사용하면 컴파일러는 문자 하나를 읽으라는
뜻으로 알아 듣는다. (함수의 오버로딩)

9.
getline() 대신에 get()을 사용하는 이유는 옛날 C++에는 getline()이 없었기 때문이다.
그리고 get()이 사용자를 다소 신중하게 만들어 주기 때문이다. 다시말해 get()은 에러 체킹이 좀 더 쉽다.
문자가 잘 들어갔는지 확인하기 위해 get()을 써서 개행문자면 성공 다른 문자가 나오면 실패라는 것을 알 수 있다.

10.
만약 get()이 빈 행을 읽는 다면 failbit라는 것이 설정된다. getline()은 아니다.
이 행동이 뜻하는 것은 계속되는 입력을 막고, 입력을 복원하려면 cin.clear()를 사용해야 한다.
입력 행이 지정된 문자 수 보다 크면 나머지 문자들을 입력 큐에 그대로 남겨둔다. 
그러나 부가적으로 getline()은 failbit를 설정하고 더 이상의 입력을 받지 않는다. get()은 아니다.

