1.
함수 오버로딩은 언제 사용하는가?
디폴트 매개변수를 사용하여 같은 목적을 수행할수 있으면 디폴트 매개변수로 하는것이 좋다
하지만 서로 다른 데이터형의 매개변수를 요구하고, 디폴트 매개변수가 소용이 없을 때에는 함수 오버로딩을 사용해야 한다.

2.
C++는 오버로딩된 함수들 중에서 어느것이 어느것인지 과연 어떻게 추적할까? C++ 컴파일러는 사용자를 대신하여 이름 장식
또는 이름 맹글링 이라는 마술을 부린다. 그것은 함수 원형에 지정되어 있는 형식 매개변수의 데이터형을 기반으로 각각의 함수 이름을
암호화하는 것이다 예를 들어 다음과 같은 장식되지 않은 함수 원형이 있다고 가정하자
long MyFunctionFoo(int, float) 컴파일러는 스스로의 용도를 위해 이형식을 다음과 같이 좀 더 알아보기 어려운 내부 형식으로 변환한다.
?MyFunctionFoo@@YAXH@Z 이러한 겉보기 장식은 매개변수의 개수와 데이터형을 암호화하는것이다. 시그내처(함수원형 매개변수)가 다르면
기호들이 다른 방식으로 덧붙는다. 컴파일러가 다르면 이름 장식이 다른 방법으로 이루어진다.

3.
함수 템플릿: 만약 두개의 int 값을 교환하는 함수를 정의했다. 이번에는 int값 대신에 두 개의 double값을 교환해야 한다고 가정하자
이것을 해결하는 한가지 방법은 int 값을 교환하는 함수를 복사하여 int를 각각 double로 바꾸는 것이다 이런 상황이 발생할 떄마다 매번
이런식으로 데이터형을 바꾼다는 것은 귀중한 시간을 낭비할 뿐만 아니라 실수를 저지를 위험도 있다. C++의 함수 템플릿 기능은 이 과정을
자동화하여 시간을 절약하고 코드의 신뢰성을 높여준다.(템플릿은 함수를 만드는 것이 아니다 함수를 정의하는 방법을 컴파일러에게 알려주는 것이다)
즉 템플릿은 정의하는법을 컴파일러에게 알려주고 컴파일러는 자동적으로 작성해준다.

4.
함수 템플릿이 실행 프로그램을 짧게 만들어 주지는 않는다. 템플릿의 장점은 여러 개의 함수 정의를 더 간단하고 더 신뢰성 있게 생성한다는
것이다.

5.
(특수화 방식을 모두 실험한 후, C++98 표준은 이방식을 다음과 같이 정립하였다.)
1.함수 이름이 하나 주어지면, 사용자는 템플릿이 아닌 함수, 템플릿 함수, 명시적 특수화 템플릿 함수를 가질 수 있다. 또한 이 모든 것들의 오버로딩 버전도 가질수 있다.
2.명시적 특수화를 하기 위한 원형과 정의 앞에 template<>가 와야 한다. 그리고 그 특수형의 이름을 서술해야 한다
3.특수화는 템플릿을 무시하고 템플릿이 아닌 함수는 특수화와 템플릿 둘 다를 무시한다.

6.
템플릿이 아닌 함수원형 = void Swap(job &, job &)
템플릿 원형 = template <typename T> void Swap(T &, T &)
job형을 위한 명시적 특수화 = template <> void Swap<job>(job &, job &)

7.
특정 매개변수에 대해서 별도처리를 하고 싶은 경우 명시적 특수화를 사용하며 오버로딩또한 가능하다.
함수는 명시적 특수화만 가능하고 호출 우선순위는 아래와 같다.
일반함수 > 명시적 특수화 템플릿 함수 > 템플릿 함수

8.
명시적 구체화: template void Swap<int>(int,int) 이 선언은 Swap() 템플릿을 사용하여 int형에 맞는 함수 정의를 생성하라는 의미이다.
명시적 특수화: template <> void Swap<int>(int, int) 이 선언들은 함수 정의를 생성하기 위해 Swap() 템플릿을 사용하지 말고 int형에
맞게 특별히 명시적으로 정의된 함수 정의를 사용하라는 것을 의미한다. 






