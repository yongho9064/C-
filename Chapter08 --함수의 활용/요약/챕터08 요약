// C언어는 없고 C++에 새로 추가된 기능들

1.
인라인 함수: 프로그램의 실행 속도를 높이기 위해 C++에 새로 보강되었다. 일반 함수와 인라인 함수의 가장 큰 차이점은
일반함수의 경우에는 그 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 돌아온다.(스택 프레임 검색)
인라인 함수는 그 자리에서 처리하므로 일반 함수보다 약간 빠르게 수행된다 하지만! 메모리 사용 측면에서는 인라인 함수가 일반 함수보다
불리하다. 인라인 함수를 열번 호출한다면 프로그램은 그 함수의 복사본을 프로그램의 코드 안에 열번이나 삽입하기 때문이다.
(함수 코드를 수행하는 데 걸리는 시간이 매우 짧을 경우에만 인라인 함수를 사용하는것이 좋다!)
(컴파일러가 함수의 덩치가 크다는 이유로 또는 재귀호출이라는 이유로 거절하는 컴파일러도 있다.)(인라인 함수는 재귀호출 허용안해준다.)
(현대 컴파일러는 자동으로 함수를 인라인화 하는 데 매우 뛰어나다. 함수를 인라인으로 표시하지 않더라도 컴파일러는 성능이 향상될 것으로 
생각하는 함수를 인라인화 한다. 따라서 대부분의 경우 inline 키워드를 사용할 필요가 없다.)

2.
참조 변수(int&): 참조를 선언할 떄 참조 변수를 함께 초기화해야 한다. 참조는 대입문이 아니라 초기화 선언에 의해서만 설정할 수 있다.
참조의 주된 용도는 함수의 매개변수에 사용하는 것이다. (참조 매개변수는 구조체나 클래스와 같이 덩치 큰 데이터를 다룰 떄에나 유익하다.)

3.
참조 변수에 표현식을 전달할수없다. (int &a = b + 3.0) // 표현식 X

4.
임시 변수가 언제 생성되는 것일까? (const 참조의 경우에만 임시 변수 생성을 허용해준다.)
1. 실제 매개변수가 올바른 데이터형이지만 lvalue가 아닐떄
2. 실제 매개변수가 잘못된 데이터형이지만 올바른 데이터형으로 변환할 수 있을 때
lvalue란 lvalue 매개변수는 참조가 가능한 데이터 객체이다. 예를 들어 "변수, 배열의 원소, 구조체의 멤버, 참조 또는 역참조 포인터는"
lvalue이다. 일반 상수(주소에 의해서 표시되는 인용 구문과는 별개로)와 여러 개의 항으로 이루어진 표현식은 lvalue가 아니다.

5.
임시 변수는 함수가 호출되어 있는 동안 유지되지만, 그 후에 컴파일러는 그것을 마음대로 없앨 수 있다.

6.
C++11은 rvalue 참조라고 부르는 두번째 종류의 참조를 소개하고 있는데 rvalue를 참조할 떄 사용할 수 있으면
&&를 사용하여 다음과 같이 선언한다. double && jref = 2.0 + 18.5 // double &는 허용되지 않는다.
단일 &을 사용하여 선언하는 경우는 lvalue 참조라고 부른다.

7.
lvalue 단일 표현식 이후에도 없어지지 않고 지속되는 객체입니다. 쉽게 생각해서 이름을 가지는 객체는 Lvalue라고 얘기할 수 있죠. 
그러므로 const 타입을 포함한 모든 변수는 Lvalue 입니다. 
반면에 Rvalue는 표현식이 종료된 이후에는 더이상 존재하지 않는 임시적인 값입니다. 
int i = 3   // i는 lvalue 3은 rvalue

8.
함수가 리턴하는 값은 복사되어 임시기억공간에 저장이 된다. 이 값은 따로. 저장하지 않으면 버려지므로 다른 변수에 저장해서 사용한다

9.
참조를 리턴하는것이 메모리를 관리할때 가장 효율적이다.

10.
ostream을 기초 클래스(부모클래스) ofstram을 파생클래스(자식클래스)라고 한다.
파생 클래스는 기초 클래스의 메서드를 상속한다 ofstram객체가 precision(),setf() 등의 포멧팅 메서드와 같은 기초 클래스의
기능을 사용할 수 있다는 것을 의미한다.

11.
참조 매개변수를 사용하는 주된 이유는 다음 두 가지 이다.
1. 호출 함수에 있는 데이터 객체의 변경을 허용하기 위해
2. 전체 데이터 객체 대신에 참조를 전달하여 프로그램의 속도를 높이기 위해
두번쨰 이유는 구조체나 클래스 객체와 같이 덩치 큰 데이터 객체를 다룰 떄 가장 중요하다.

12.
클래스 객체 매개변수의 전달은 참조로 전달하는 것이 표준이다.

13.
C++에 새로 추가된 기능인 디폴트 매개변수를 살펴보자. 디폴트 매개변수는 함수 호출에서 실제 매개변수를 생략했을 경우에
실제 매개변수 대신 사용되는 값이다. 디폴트 값은 어떻게 설정하는가? 함수원형을 사용하면된다.
매개변수를 디폴트 매개변수로 만들려면, 그 매개변수보다 오른쪽에 있는 모든 매개변수를 디폴트 매개변수로 만들어야한다. 
예) int harpo(int n, int m = 4, int j = 5) // 함수원형
그러나! 매개변수는 건너뛸수 없다 즉 다음과 같은 것은 허용되지 않는다.
beeps = harpo(3, ,8) // 허용안됨!

14.
함수 오버로딩을 가능하게 하는 것은 함수의 데이터형이 아니라 시그내처(함수원형 매개변수)라는 사실을 항상 명심하라
예를 들어, 다음 두 선언은 함께 공존할 수 없다.
long gronk(int n, float m)              // 같은 시그내처이므로
double gronk(int n, float m)            // 공존 할수 없다
그러므로 C++는 이러한 형태로 gronk() 함수를 오버로딩 하는 것을 허용하지 않는다. 시그내처(함수원형 매개변수)가 다를 경우에만 다른 리턴형을
가질수 있다.
